# 캐릭터가 있는 장소는 1*1크기의 정사각형으로 이루어진 n*m크기의 매트릭스이다.
# 각각의 칸은 육지 또는 바다이다. 육지로는 갈 수 없다.
# 맵의 각 칸은 (a,b)로 나타낼 수 있고, a는 북쪽으로부터 떨어진 칸의 개수,b는 서쪽으로부터 떨어진 칸의 개수이다.
# 캐릭터는 상하좌우로 움직일 수 있고 바다로는 갈 수 없다.
# 설정메뉴얼
# 1. 현재 위치에서 현재 방향기준 왼쪽 방향부터 차례대로 갈 곳을 정한다.
# 2. 왼쪽방향에 안가본 곳이 있다면, 왼쪽방향으로 회전 후 한 칸 전진. 왼쪽방향에 가보지 않은 칸이 없다면
#    왼쪽방향으로 회전만하고 1단계로 돌아감
# 3. 4방향 모두 가본 칸이거나 바다인 경우 한 칸 뒤로 가고 1단계로 돌아감(방향은 유지). 단 한칸뒤가 바다인경우 움직임을 멈춤
# 캐릭터가 방문한 칸의 수를 출력하는 프로그램을 만드시오

# 입력조건
# 첫째 줄에 맵의 세로 크기 n과 가로크기m을 공백으로 구분하여 입력한다.(n은 3보다 크거나 같고 m은 50보다 작거나 같음)
# 둘째 줄에 게임 캐릭터가 있는 칸의 좌표 (a,b)와 바라보는 방향 d가 각각 서로 공백으로 구분하여 주어진다.
# 방향 d의 값으로는 다음과 같이 4가지가 존재
# 0 ,1, 2, 3 = 북,동,남,서
# 셋째 줄부터 맵이 육지인지 바다인지에 대한 정보가 주어진다. n개의 줄에 맵의 상태가 북쪽부터 남쪽 순서대로,
# 각 줄의 데이터는 서쪽부터 동쪽 순서대로 주어진다. 맵의 외각은 항상 바다로 되어있다.
# 0,1 = 육지,바다
# 처음에 캐릭터가 위치한 곳은 육지

# 출력조건
# 첫째 줄에 이동을 마친 후 캐릭터가 방문한 칸의 수를 출력한다.

# n,m을 공백으로 구분하여 입력받기
n,m = map(int,input().split())#n=행,m=열

# 방문한 위치를 저장하기 위한 맵을 생성하여 0으로 초기화
d = [[0]*m for _ in range(n)]# m개의0이 n줄 있는 초기 매트릭스 생성
# 현재 캐릭터들의 x,y좌표, 방향을 입력받기
x,y,direction = map(int,input().split())
# 현재 좌표 방문처리
d[x][y] = 1

# 전채 맵 정보를 입력받기
array = []
for i in range(n):
    array.append(list(map(int, input().split())))

# 북동남서 방향 정의
dx = [-1,0,1,0]#북쪽이면 캐릭터좌표가(-1,0)만큼 이동
dy = [0,1,0,-1]#동쪽이면 (0,1)만큼 이동

# 왼쪽으로 회전
def turn_left():
    #  direction인 지역변수를 global함수를 통해 전역변수로 사용
    global direction
    direction -= 1# 캐릭터가 왼쪽으로 이동하면서 동북서남방향으로 돌아가기 때문에 -1씩해주면서 돌아감
    if direction == -1:
        direction = 3# 무한으로 돌도록 함

# 시물레이션 시작
count = 1
turn_time = 0
while True:
    # 왼쪽으로 회전
    turn_left()
    nx = x + dx[direction]#이동 후 x좌표
    ny = y + dx[direction]#이동 후 y좌표

    # 회전한 이후 정면에 가보지 않은 칸이 존재 하는 경우 이동
    if d[x][y] == 0 and array[nx][ny] == 0:
        d[nx][ny] = 1
        x = nx #이동좌표를 원래 좌표에 덮어씌어 x가 이동하게 함
        y = ny #이동좌표를 원래 좌표에 덮어씌어 y가 이동하게 함
        count += 1
        turn_time = 0
        # continue#이거 왜 하는지 모르겠음
#     회전한 이후 정면에 가보지 않은 칸이 없거나 바다인 경우 좌표 이동
    else:
        turn_time += 1
#     4방향 모두 갈 수 없는 경우
    if turn_time == 4: #4번 다 돌았으면 뒤로 가기
#       뒤로 갈 수 있다면 이동
        nx = x - dx[direction]  # 이동 후 x좌표
        ny = y - dx[direction]  # 이동 후 y좌표
        if array[nx][ny] == 0:
           x = nx
           y = ny
#       뒤로 바다인경우
        else:
            break
        turn_time = 0
print(count)
