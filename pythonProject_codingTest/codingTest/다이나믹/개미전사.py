## 개미 전사는 부족한 식량을 충당하고자 메뚜기 마을의 식량창고를  공격할 예정
# 식량창고는 일직선으로 이어져있다.
# 각 식량창고에는 정해진 수의 식량을 저장하고 있으며 개미전사는 식량창고를 선택적으로 약탈하여 식량을 뺏을 예정
# 이때 메뚜기 정찰병들은 일직선상에 존재하는 식량창고 중에서 서로 인접한 식량창고가 공격받으면 바로 알아챌 수 있다.
# 따라서 개미 전사가 정찰병에게 들키지 않고 식량창고를 약탈하기 위해서는
# 최소한 한 칸 이상 떨어진 식량창고를 약탈해야한다.
# 예시: 1 3 1 5
# 이때 개미전사는 두번째와 네번째 식량창고를 선택했을 때 총 8개의 식량을 뺏을 수 있다.
# 개미전사를 위해 식량창고 n개에 대한 정보가 주어졌을 때 얻을 수 있는 식량의 최댓값을 구하는 프로그램을 작성하세요
#
# 입력조건: 첫째 줄에 식량창고 개수n이 주어진다.(3~100사이)
#           둘째 줄에 공백을 기준으로 식량창고에 저장된 식량의 개수 k가 주어진다.(0~1000)
# 출력조건: 첫째 줄에 개미 전사가 얻을 수 있는 식량의 최댓값을 출력하세요
# #
# n = int(input())
# array = list(map(int, input().split()))
# d = [0]*100
#
# d[0] = array[0]
# d[1] = max(array[0], array[1])
#
# for i in range(2,n):
#     d[i] = max(d[i-1], d[i-2] + array[i])
# print(d[n-1])

# #
n = int(input())
array = list(map(int, input().split()))

# 앞서 계산된 결과를 저장하기 위한 dp테이블 초기화
d = [0]*100

# 다이나믹 프로그래밍 진행(보텀업)
# array에서 1번째 중에서 가장 큰 값은 array[0]
d[0] = array[0]
# array에서 1~2번째 값 중에서 가장 큰 값은 array[0], array[1] 둘 중에 하나
d[1] = max(array[0], array[1])
# 3번째부터는 for문으로 돌려준다
for i in range(2, n):
    # 최대값 인접한 곳에 또 최대값이 있는 경우:
    # 이전 최대값과 다음 최대값+전전 값을 비교하여 더 큰 값을 선택
    # 예를들어 1 3 4 5 이면 d[2]는 d[1]=3과 d[1]+array[2] = 5중 5를 선택하게 된다.
    # d[i] 번째 값은 0~i까지 중에서 가장 큰 값이 이전에 선택한 값 d[i-1]일 경우
    # array[i]를 선택할 수 없으므로 최대값은 d[i-1]가 되고, d[i]에 d[i-1]을 넣는다.
    # 최대값 인접하지 않은 곳에 최대값이 있는 경우:
    # d[i-2]가 d[i-1]보다 클 경우 array[i]번째 값을 선택할 수 있으므로
    # d[i-2] + array[i]값이 d[i]가 된다.
    d[i] = max(d[i-1], d[i-2] + array[i])
    print(d[i])
    print(d)
# 계산된 결과 출력
print(d[n-1])# d의 인덱스가 0부터 시작하므로 하나작은n-1로 지정해준다.

