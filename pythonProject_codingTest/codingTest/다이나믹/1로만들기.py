# 정수 x가 주어졌을 때 x에 사용할 수 있는 연산은 아래와 같다.
# 1.x가 5로 나누어 떨어지면 5로 나눔
# 2.x가 3으로 나누어 떨어지면 3으로 나눔
# 3.x가 2로 나누어 떨어지면 2로 나눔
# 4.x에서 1을 뺌
# 정수 x가 주어졌을 때 연산 4개를 적절히 사용해서 값을 1로 만들고자 한다.
# 연산 횟수의 최소값을 출력하세요
#
# 입력조건: 첫째 줄에 정수 x가 주어진다.(1~30000)
# 출력조건: 첫째 줄에 연산을 하는 횟수의 최소값을 출력합니다.
# 예로 26을 입력하면 출력값은 3이다.(26-25-5-1)
# ##
x = int(input())
# 다이나믹 풀때는 무조건 dp테이블 초기화된 d를 작성
d = [0]*30001#x의 최대값이 1부터 3만이므로

# x를 1로 만들기 위한 최소연산의 횟수는 아래 점화식과 같다.
#  ai = min(a(i-1),a(i/2),a(i/3),a(i/5))+1
#  +1은 연산 횟수를 1씩 증가해야 하므로 넣어준다.

# 다이나믹 프로그래밍 진행
for i in range(2, x+1):
    # 현재 수에서 1을 빼는 경우
    # i가 x값중 일부이므로 한 칸 뒤로 가기 위해서 x-1을 해주고 (d[x-1]),연산횟수 +1을 해준다.
    d[i] = d[i-1] + 1
    print('-1',d)
    # 현재 수가 2로 나누어 떨어질 때
    if i % 2 == 0:
        # 2로 나누었을 때 연산의 최소값.
        # d[i//2]가 d[i](d[i-1]+1한 값.즉, 기존값에 1 뺀 값)보다 작은경우 +1을 해준 d[i//2]+1를 d[i]로 선택한다 .
        d[i] = min(d[i], d[i//2]+1)
        print('2',d)
    # 현재 수가 3로 나누어 떨어질 때
    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)
        print('3',d)
    # 현재 수가 5로 나누어 떨어질 때
    if i % 5 == 0:
        d[i] = min(d[i], d[i // 5] + 1)
        print('5',d)
print('d',d)
print(d[x])

# 하나뺀 값과 2,3,5로 나눈값을 비교하여 더 작은 값을  채택하고
# 작은수부터 마지막 수까지 차례대로 증가시켜 마지막 수에서 나누면
# 나눈수가 이미 이전에 다 연산횟수 카운트 되어있으므로 효율적으로 최소연산 값을 구할 수 있다.